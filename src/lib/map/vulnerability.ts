// vulnerability.ts
// -----------------------------------------------------------
// Construcción de radios (para Lobster) y estimación de víctimas
// por anillos, con:
//  - Fireball modulado por exterior/interior y nubosidad
//  - Quemaduras 3º/2º moduladas (y guarda burns3rd ≤ burns2nd)
//  - Blast con encogimiento HOB-like (ATAP) para 20/5 kPa
//  - Sismo conservador (equivalente a εs=1e-4) sin tocar impact.ts
//  - Caps y orden de asignación sin doble conteo
//
// Firmas públicas (mantienen compat con tu retrieveImpactData.ts):
//   - buildRadiiForPopulation(outputs): number[]
//   - estimateCasualtiesByRings(outputs, radiiForPop, populations): CasualtyEstimateResult
// -----------------------------------------------------------

export type CasualtyTotals = {
  craterVaporized: number;
  fireballDeaths: number;
  burns3rd: number;
  burns2nd: number;
  shockwaveDeaths: number;
  windDeaths: number;
  earthquakeDeaths: number;
};

export type CasualtyEstimateResult = {
  totals: CasualtyTotals;
  radiiUsed: number[]; // eco de radios usados (m)
  // rings?: number[]; // opcional para debug/UI
};

// ---------------- Parámetros/calibración (todas las "perillas") ----------------
// Ajustados para acercar el caso Ecuador a: fireball ≈ 1.5–2.0 M (≥ crater),
// shockwave más bajo en el borde lejano, y sismo conservador.

const CAL = {
  // Exposición ambiental (puedes parametrizar esto desde UI en el futuro)
  ENV: {
    isDaytime: true,     // si no se pasa contexto, asumimos día
    p_out_day: 0.55,     // fracción al aire libre (día)
    p_out_night: 0.20,   // fracción al aire libre (noche)
    p_cloud: 0.75,       // nubosidad/visibilidad efectiva (0.6–1.0)
    // Edificación / ocupación interior para blast
    q_build: 0.5,        // 0=excelente, 1=precaria (default intermedio)
    p_in: 0.8            // fracción en interiores (relevante para blast)
  },

  // Fireball (letalidad en el anillo de ignición)
  FIREBALL: {
    BASE_LETHAL_FRAC: 0.32,  // ↓ (antes 0.56)
    CAP_BY_RING: 0.40,       // ↓ (antes 0.52)
    ANGLE_MIN: 0.75,         // rasante
    ANGLE_MAX: 1.00          // vertical
  },

  // Térmico (quemaduras). Se modulán por p_out y p_cloud
  BURNS: {
    FRAC_3RD_BASE: 0.22,     // 3º base
    FRAC_2ND_BASE: 0.58,     // 2º base
    MAX_3RD_VS_2ND_RATIO: 1.0 // fuerza burns3rd ≤ burns2nd
  },

  // Blast (letalidad por anillo), modulado por q_build y p_in
  BLAST: {
    // Valores base "centrales", que luego se modulan:
    F50_BASE: 0.010,         // 1.0% + 0.02*q_build → 1–3%
    F20_BASE: 0.001,         // 0.1% + 0.006*q_build → 0.1–0.7%
    F5_BASE:  0.0001,        // 0.01% + 0.0003*q_build → 0.01–0.04%
    CAP_BY_RING: 0.035       // tope por anillo (3.5%)
  },

  // Encogimiento HOB-like (ATAP) para 20/5 kPa
  HOB: {
    E1_MT: 50,               // por debajo: sin corrección
    E2_MT: 5000,             // por encima: corrección plena
    ALPHA: 0.08              // fuerza de encogimiento en r ∝ (E2/E)^alpha
  },

  // Define cómo convertir radios térmicos de ignición a "bola de fuego visible"
  FIREBALL_RADIUS: {
    SCALE_FROM_IGN: 0.90,    // ↓ (antes 0.92)
    H_EFF_M: 7000            // altura efectiva (m) para horizonte (fallback)
  },

  // Viento: muy por debajo del blast y acotado por él
  WIND: {
    FRAC_BASE: 0.00015,      // 0.015% por anillo
    CAP_BY_RING: 0.003,      // 0.3% por anillo
    MAX_VS_BLAST: 0.20       // ≤20% de muertes por blast
  },

  // Sismo: letalidad muy baja (equivalente a εs=1e-4 en magnitud)
  QUAKE: {
    CAP_BY_RING: 0.001       // 0.1% por anillo
  }
};

// ---------------- Utilidades ----------------
function clamp01(x: number) { return Math.max(0, Math.min(1, x)); }
function lerp(a: number, b: number, t: number) { return a + (b - a) * t; }

function angleFactor(deg?: number) {
  const a = ((typeof deg === 'number' ? deg : 45) * Math.PI) / 180;
  return clamp01(CAL.FIREBALL.ANGLE_MIN + (CAL.FIREBALL.FIREBALL?.ANGLE_MAX ?? CAL.FIREBALL.ANGLE_MAX - CAL.FIREBALL.ANGLE_MIN) * Math.sin(a));
}

/** Factor angular puro (para radios) entre 0.90 (rasante) y 1.00 (vertical) */
function fireballAngleScale(deg?: number) {
  const a = ((typeof deg === 'number' ? deg : 45) * Math.PI) / 180;
  const K_MIN = 0.90, K_MAX = 1.00;
  return K_MIN + (K_MAX - K_MIN) * Math.sin(a);
}

function toRingsFromCumulative(cumulative: number[]): number[] {
  const rings = new Array(cumulative.length).fill(0);
  for (let i = 0; i < cumulative.length; i++) {
    rings[i] = i === 0 ? cumulative[0] : Math.max(0, cumulative[i] - cumulative[i - 1]);
  }
  return rings;
}

function sum(arr: number[], a: number, b: number) {
  let s = 0;
  for (let i = a; i <= b; i++) s += arr[i] || 0;
  return s;
}

function assignFractional(
  remaining: number[], i0: number, i1: number, frac: number, capByRing: number
) {
  let total = 0;
  for (let i = i0; i <= i1; i++) {
    if (remaining[i] <= 0) continue;
    const take = Math.min(remaining[i] * frac, remaining[i] * capByRing);
    remaining[i] -= take;
    total += take;
  }
  return Math.round(total);
}

function assignFractionalWithBreakdown(
  remaining: number[], i0: number, i1: number, frac: number, capByRing: number
) {
  const byRing = new Array(remaining.length).fill(0);
  let total = 0;
  for (let i = i0; i <= i1; i++) {
    if (remaining[i] <= 0) continue;
    const take = Math.min(remaining[i] * frac, remaining[i] * capByRing);
    remaining[i] -= take;
    byRing[i] = take;
    total += take;
  }
  return { total: Math.round(total), byRing };
}

function shrinkToTotal(byRing: number[], targetTotal: number) {
  const current = byRing.reduce((a, b) => a + b, 0);
  if (current <= 0 || targetTotal >= current) return byRing;
  const k = targetTotal / current;
  return byRing.map(v => Math.floor(v * k));
}

function nearIdx(arr: number[], value: number) {
  if (!isFinite(value) || value <= 0) return Math.min(arr.length - 1, 0);
  let best = 0, bestd = Infinity;
  for (let i = 0; i < arr.length; i++) {
    const d = Math.abs(arr[i] - value);
    if (d < bestd) { bestd = d; best = i; }
  }
  return best;
}

// --------- Encogimiento HOB-like (ATAP) para radios lejanos 20/5 kPa ----------
/** factor de encogimiento en función de E (MT): 1 en E<=E1; (E2/E)^alpha en E>=E2; interpola en medio */
function hobShrinkFactor(E_MT: number): number {
  const { E1_MT, E2_MT, ALPHA } = CAL.HOB;
  if (!isFinite(E_MT) || E_MT <= 0) return 1;
  if (E_MT <= E1_MT) return 1;
  if (E_MT >= E2_MT) return Math.pow(E2_MT / E_MT, ALPHA);
  // interpola log-lineal entre E1 y E2
  const t = (Math.log(E_MT) - Math.log(E1_MT)) / (Math.log(E2_MT) - Math.log(E1_MT));
  const fE2 = Math.pow(E2_MT / E_MT, ALPHA);
  return lerp(1, fE2, t);
}

// ---------------- Construcción de radios (para Lobster) -----------------------
//
// Devuelve SOLO el array de radios (m), ordenado y deduplicado.
// Aplica encogimiento HOB-like a 20/5 kPa (no toca 50 kPa).
export function buildRadiiForPopulation(outputs: any): number[] {
  const angleDeg = outputs?.inputs?.angle ?? outputs?.angle ?? 45;
  const E_MT = outputs?.energy?.MT ?? outputs?.energyMT ?? 0;

  // Cráter: 0.5*Df (mín 10 m)
  const Df = outputs?.finalCraterDiameter ?? outputs?.crater?.finalDiameter_m ?? outputs?.crater?.finalDiameter ?? 0;
  const R_crater = Math.max(10, 0.5 * Df);

  // Térmico (claves según tu JSON actual):
  const R_ign = outputs?.thermalRadii?.ignition
             ?? outputs?.thermalRadii_m?.ignition_1MJm2
             ?? outputs?.thermalRadii_m?.["1.0_MJ_m2"]
             ?? 0;

  const R_burn2 = outputs?.thermalRadii?.burns2ndDeg
               ?? outputs?.thermalRadii_m?.burns2ndDeg_0_25MJm2
               ?? outputs?.thermalRadii_m?.["0.25_MJ_m2"]
               ?? Math.max(R_ign * 1.35, R_ign);

  const R_burn3_explicit = outputs?.thermalRadii?.burns3rdDeg
                        ?? outputs?.thermalRadii_m?.burns3rdDeg_0_5MJm2
                        ?? outputs?.thermalRadii_m?.["0.5_MJ_m2"];
  const R_burn3 = R_burn3_explicit ?? Math.max(R_ign * 1.45, (R_ign + R_burn2) / 2);

  // Fireball: desde R(1 MJ/m²) con modulación angular + horizonte
  const kAngle = fireballAngleScale(angleDeg);
  let R_fireball_geom = Math.max(0, R_ign * CAL.FIREBALL_RADIUS.SCALE_FROM_IGN * kAngle);

  // Curvatura/visibilidad (horizonte):
  const Re = 6_371_000;
  const h_eff = CAL.FIREBALL_RADIUS.H_EFF_M;
  const R_horizon = Math.sqrt(2 * Re * Math.max(1, h_eff));
  const R_fireball = Math.min(R_fireball_geom, R_horizon);

  // Blast (claves según tu JSON actual)
  const R_b50 = outputs?.blastRadii?.severe
             ?? outputs?.blastRadii_m?.severe_50kPa
             ?? outputs?.blastRadii_m?.["50_kPa"]
             ?? 0;
  let R_b20 = outputs?.blastRadii?.moderate
            ?? outputs?.blastRadii_m?.moderate_20kPa
            ?? outputs?.blastRadii_m?.["20_kPa"]
            ?? Math.max(R_b50, 0);
  let R_b5  = outputs?.blastRadii?.windows
            ?? outputs?.blastRadii_m?.windows_5kPa
            ?? outputs?.blastRadii_m?.["5_kPa"]
            ?? Math.max(R_b20, 0);

  // Encogimiento HOB-like para 20/5 kPa
  const fHOB = hobShrinkFactor(E_MT);
  R_b20 *= fHOB;
  R_b5  *= fHOB;

  // Buffer exterior
  const maxOuter = Math.max(R_b5, R_burn2);
  const R_buffer = Math.max(1, maxOuter * 1.15);

  // Ordenar y deduplicar
  const eps = 1e-6;
  const raw = [R_crater, R_fireball, R_burn3, R_burn2, R_b50, R_b20, R_b5, R_buffer]
    .filter(r => isFinite(r) && r > 0)
    .sort((a, b) => a - b);

  const radii_m: number[] = [];
  for (const r of raw) {
    if (radii_m.length === 0 || Math.abs(r - radii_m[radii_m.length - 1]) > eps) {
      radii_m.push(r);
    }
  }

  return radii_m;
}

// ---------------- Estimación de víctimas (como usa tu retrieve) ---------------
//
// Entradas:
//  - outputs: (usamos angle y energy para modulación)
//  - radiiForPop: radios (m) enviados a Lobster
//  - populations: acumuladas de Lobster (paralelas a radiiForPop)
//
// Salida: { totals: {...}, radiiUsed: radiiForPop }
export function estimateCasualtiesByRings(
  outputs: any,
  radiiForPop: number[],
  populations: number[]
): CasualtyEstimateResult {
  const angleDeg = outputs?.inputs?.angle ?? outputs?.angle ?? 45;
  const E_MT = outputs?.energy?.MT ?? outputs?.energyMT ?? 0;

  // Contexto ENV
  const isDaytime = CAL.ENV.isDaytime;
  const p_out = isDaytime ? CAL.ENV.p_out_day : CAL.ENV.p_out_night;
  const p_cloud = CAL.ENV.p_cloud;
  const q_b = CAL.ENV.q_build;
  const p_in = CAL.ENV.p_in;

  if (!Array.isArray(radiiForPop) || !Array.isArray(populations) || radiiForPop.length !== populations.length) {
    return { totals: zeroTotals(), radiiUsed: radiiForPop ?? [] };
    }

  // Mapear índices por proximidad a efectos físicos
  const idx = locateIndices(outputs, radiiForPop);

  // Población por anillo y remanente
  const rings = toRingsFromCumulative(populations);
  const remaining = rings.slice();

  // 1) CRÁTER — 100% letalidad hasta idx.crater
  const craterVaporized = Math.round(sum(rings, 0, idx.crater));
  for (let i = 0; i <= idx.crater; i++) remaining[i] = 0;

  // 2) FIREBALL — fracción sobre remanente con visibilidad y ángulo
  const fAngle   = angleFactor(angleDeg);
  const fireballFrac = clamp01(CAL.FIREBALL.BASE_LETHAL_FRAC * p_out * p_cloud * fAngle);
  const startFB = Math.min(idx.crater + 1, remaining.length - 1);

  let fireballDeaths = assignFractional(
    remaining, startFB, idx.fireball, fireballFrac, CAL.FIREBALL.CAP_BY_RING
  );
  // Guardarraíl: fireball ≥ crater
  if (fireballDeaths < craterVaporized) {
    const deficit = craterVaporized - fireballDeaths;
    const i = startFB;
    const extra = Math.min(deficit, Math.max(0, remaining[i]));
    remaining[i] -= extra;
    fireballDeaths += extra;
  }

  // 3) QUEMADURAS 3º (hasta idx.burn3) — moduladas por p_out y p_cloud
  const f3 = clamp01(CAL.BURNS.FRAC_3RD_BASE * p_out * p_cloud);
  const { total: burns3rd_raw, byRing: b3_byRing } = assignFractionalWithBreakdown(
    remaining, startFB, idx.burn3, f3, 1.0
  );

  // 4) QUEMADURAS 2º (hasta idx.burn2) — algo menos dependiente de p_out
  const f2 = clamp01(CAL.BURNS.FRAC_2ND_BASE * (0.6 * p_out + 0.4) * p_cloud);
  const { total: burns2nd_raw, byRing: b2_byRing } = assignFractionalWithBreakdown(
    remaining, startFB, idx.burn2, f2, 1.0
  );

  // Guardia fuerte: 3º ≤ 2º
  let burns3rd = burns3rd_raw;
  let burns2nd = burns2nd_raw;
  if (burns3rd > burns2nd * CAL.BURNS.MAX_3RD_VS_2ND_RATIO) {
    const target = Math.floor(burns2nd * CAL.BURNS.MAX_3RD_VS_2ND_RATIO);
    const b3_shrunk = shrinkToTotal(b3_byRing, target);
    for (let i = startFB; i <= idx.burn3; i++) {
      const giveBack = b3_byRing[i] - b3_shrunk[i];
      if (giveBack > 0) remaining[i] += giveBack;
    }
    burns3rd = target;
  }

  // 5) BLAST letal (50→20→5 kPa) — modulado por q_build y p_in
  const f50 = Math.min(CAL.BLAST.CAP_BY_RING, (CAL.BLAST.F50_BASE + 0.020 * q_b) * (0.7 + 0.3 * p_in));
  const f20 = Math.min(CAL.BLAST.CAP_BY_RING, (CAL.BLAST.F20_BASE + 0.006 * q_b) * (0.6 + 0.4 * p_in));
  const f5  = Math.min(CAL.BLAST.CAP_BY_RING,  CAL.BLAST.F5_BASE  + 0.0003 * q_b);

  const deaths50 = assignFractional(remaining, startFB, idx.blast50, f50, CAL.BLAST.CAP_BY_RING);
  const deaths20 = assignFractional(remaining, idx.blast50 + 1, idx.blast20, f20, CAL.BLAST.CAP_BY_RING);
  const deaths5  = assignFractional(remaining, idx.blast20 + 1, idx.blast5,  f5,  CAL.BLAST.CAP_BY_RING);
  const shockwaveDeaths = deaths50 + deaths20 + deaths5;

  // 6) VIENTO letal (muy bajo y acotado por blast)
  let windDeaths = assignFractional(remaining, startFB, idx.blast5, CAL.WIND.FRAC_BASE, CAL.WIND.CAP_BY_RING);
  windDeaths = Math.min(windDeaths, Math.floor(CAL.WIND.MAX_VS_BLAST * shockwaveDeaths));

  // 7) SISMO (bajo) — equivalente a usar εs=1e-4 en Mw; evita inflar
  const quakeFrac = quakeLethalityFrac(E_MT); // 0–0.0001 típicamente
  const earthquakeDeaths = assignFractional(remaining, startFB, idx.buffer, quakeFrac, CAL.QUAKE.CAP_BY_RING);

  return {
    totals: {
      craterVaporized: Math.round(craterVaporized),
      fireballDeaths:  Math.round(fireballDeaths),
      burns3rd:        Math.round(burns3rd),
      burns2nd:        Math.round(burns2nd),
      shockwaveDeaths: Math.round(shockwaveDeaths),
      windDeaths:      Math.round(windDeaths),
      earthquakeDeaths:Math.round(earthquakeDeaths)
    },
    radiiUsed: radiiForPop
    // , rings: rings // si quieres exponerlo luego
  };
}

// ----------- Sismo conservador: fracción de letalidad según E (MT) -----------
/**
 * Aproxima Mw desde E (MT) asumiendo εs = 1e-4:
 *   M = 0.67 log10(εs * E[J]) - 5.87
 * con E[J] = E[MT] * 4.184e15. De ahí deriva una fracción muy baja.
 */
function quakeLethalityFrac(E_MT: number): number {
  if (!isFinite(E_MT) || E_MT <= 0) return 0;
  const eps_s = 1e-4;
  const E_J = E_MT * 4.184e15;
  const M = 0.67 * Math.log10(eps_s * E_J) - 5.87;

  // M<5: prácticamente nula; 5–6: ~1e-5–5e-5; 6–7: ~5e-5–1e-4; cap global 1e-4
  if (M < 5.0) return 0.000002;         // 0.0002%
  if (M < 5.5) return 0.00001;          // 0.001%
  if (M < 6.5) return lerp(0.00003, 0.00008, (M - 5.5)); // 0.003–0.008%
  return 0.0001; // 0.01% como máximo nominal
}

// ---------------- Helpers de mapeo de índices --------------------------------
//
// Identifica la posición en radiiForPop de cada efecto, usando "outputs".
function locateIndices(outputs: any, radii: number[]) {
  const crater = nearIdx(radii, Math.max(10, 0.5 * (
    outputs?.finalCraterDiameter ?? outputs?.crater?.finalDiameter_m ?? outputs?.crater?.finalDiameter ?? 0
  )));
  const fireball = nearIdx(radii,
    (outputs?.thermalRadii?.ignition ??
     outputs?.thermalRadii_m?.ignition_1MJm2 ??
     outputs?.thermalRadii_m?.["1.0_MJ_m2"] ?? 0) * CAL.FIREBALL_RADIUS.SCALE_FROM_IGN
  );
  const burn3 = nearIdx(radii,
    outputs?.thermalRadii?.burns3rdDeg ??
    outputs?.thermalRadii_m?.burns3rdDeg_0_5MJm2 ??
    outputs?.thermalRadii_m?.["0.5_MJ_m2"] ??
    (outputs?.thermalRadii?.ignition ?? 0) * 1.45
  );
  const burn2 = nearIdx(radii,
    outputs?.thermalRadii?.burns2ndDeg ??
    outputs?.thermalRadii_m?.burns2ndDeg_0_25MJm2 ??
    outputs?.thermalRadii_m?.["0.25_MJ_m2"] ??
    (outputs?.thermalRadii?.ignition ?? 0) * 1.35
  );
  const blast50 = nearIdx(radii,
    outputs?.blastRadii?.severe ??
    outputs?.blastRadii_m?.severe_50kPa ??
    outputs?.blastRadii_m?.["50_kPa"] ?? 0
  );
  const blast20 = nearIdx(radii,
    outputs?.blastRadii?.moderate ??
    outputs?.blastRadii_m?.moderate_20kPa ??
    outputs?.blastRadii_m?.["20_kPa"] ?? 0
  );
  const blast5 = nearIdx(radii,
    outputs?.blastRadii?.windows ??
    outputs?.blastRadii_m?.windows_5kPa ??
    outputs?.blastRadii_m?.["5_kPa"] ?? 0
  );
  const buffer = radii.length - 1;

  // mantener monotonicidad y mínimos
  const idxs = [crater, fireball, burn3, burn2, blast50, blast20, blast5, buffer].map(i => Math.max(0, Math.min(i, buffer)));
  return {
    crater: idxs[0],
    fireball: Math.max(idxs[0], idxs[1]),
    burn3: Math.max(idxs[0], idxs[2]),
    burn2: Math.max(idxs[0], idxs[3]),
    blast50: Math.max(idxs[0], idxs[4]),
    blast20: Math.max(idxs[0], idxs[5]),
    blast5: Math.max(idxs[0], idxs[6]),
    buffer: idxs[7]
  };
}

function zeroTotals(): CasualtyTotals {
  return {
    craterVaporized: 0,
    fireballDeaths: 0,
    burns3rd: 0,
    burns2nd: 0,
    shockwaveDeaths: 0,
    windDeaths: 0,
    earthquakeDeaths: 0,
  };
}
